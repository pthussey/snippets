# Set a plot style
plt.style.use('seaborn')


# Temporarily set a new style
with plt.style.context('seaborn-whitegrid'):
    make_a_plot


# Set up figure (single plot)
fig,ax = plt.subplots()
fig.set_size_inches(8,6)


# Set up figure (multiple plots)
fig,axes = plt.subplots(ncols=1, nrows=3, sharex=True)
fig.set_size_inches(12,9)


# Axis-style plotting configurations
ax.set_title('')
ax.set_xlabel('')
ax.set_ylabel('')
ax.legend()
ax.grid()
ax.set_xlim()
ax.set_ylim()


# Plot-style plotting configurations
plt.title('')
plt.xlabel('')
plt.ylabel('')
plt.legend()
plt.grid()
plt.xlim()
plt.ylim()
plt.xticks(rotation=45)


# Change plot background
ax.set_facecolor('white')


# A default grey color
color='#b8b3b0'


# Color Brewer Oranges
#d94701, #fd8d3c, #fdbe85, #feedde, #aaaaaa


# Color Brewer Reds
#cb181d, #fb6a4a, #fcae91, #fee5d9, #aaaaaa


# Color Brewer Blues
#2171b5, #6baed6, #bdd7e7, #eff3ff, #aaaaaa


# Get all current color cycle hexcolors
print(plt.rcParams['axes.prop_cycle'].by_key()['color'])


# Setting for a muted blue-red diverging color palette
# Or can just use coolwarm for a brighter one
cmap = sns.diverging_palette(220, 20, as_cmap=True)


# Remove plot axis and label
ax.yaxis.set_visible(False)


# Add a grid and set it below the plot
ax.grid(axis='y', alpha=.4)
ax.set_axisbelow(True)


# Remove gridlines
ax.grid(False)


# Remove just one axis grid lines
ax.xaxis.grid(False)


# Adjust spacing around subplots
plt.subplots_adjust()


# One-liner that reduces the frequency of ticks
ax.set_xticks(ax.get_xticks()[::2])


# Auto format dates on x axis without needing to apply xtick rotation
fig.autofmt_xdate()


# Add thousands separator to y-axis labels
ax.get_yaxis().set_major_formatter(matplotlib.ticker.FuncFormatter(lambda x, p: format(int(x), ',')))


# Format axis ticks using string formats (example below adds dollar symbol and thousands separator)
ax.get_yaxis().set_major_formatter(
    matplotlib.ticker.FuncFormatter(
        lambda x, p: format(float(x), '${:,.0f}')))
        

# Format axis ticks using a function
ax.get_yaxis().set_major_formatter(
    matplotlib.ticker.FuncFormatter(lambda x,p : funcname(x)))


# Split any two word tick labels onto two lines
plt.xticks(np.arange(len(data)), [x.split()[0] + '\n' + x.split()[1] if len(x.split())==2 else x for x in data.index])


# Set tick locations and labels
ax.set_xticks([300, 500, 700, 1000, 1500, 2000, 2500, 
               3000, 5000, 7000, 10000])

ax.set_xticklabels([300, 500, 700, 1000, 1500, 2000, 
                    2500, 3000, 5000, 7000, 10000])


# Save the current figure
plt.savefig(fname='plot.png')


# Add text box
font = {'family': 'Malgun Gothic',
        'color':  '0.4',
        'weight': 'normal',
        'size': 10,
        }
ax.text(5, 10, "Hi There", fontdict=font)


# Add a text-only annotation for the y-value in an xy point, can also change form.format(value) to any string
coord = (x,y)
form = '{:.' + str(1) + 'f}'
plt.annotate(form.format(coord[1]),
             xy=(1,1), xytext=(10,0),
             textcoords="offset points",
             ha='left', va='bottom',
             fontsize=12,
             weight='normal', color='0.4')


# Add an annotation with an arrow, below text location set by offset points from the xy data coordinates
# Can also use 'data' to specify text location in textcoords
# If one of values in 'xy' is a date use mdates.date2num(dt.datetime(2020, 1, 1)
# Must import matplotlib mdates and datetime as dt to do that
ax.annotate('',
            xy=(1, 1), xycoords='data',
            xytext=(0.8, 0.8), textcoords='offset points',
            fontsize=10,
            arrowprops=dict(facecolor='0.4', shrink=0.05, width=2,
                            headwidth=6, headlength=4))


# Seaborn regplot with confidence interval
plt.xlim(0,100) # Might need to set xlims first if seaborn does not show everything we want
sns.regplot(x='', y='', data=, ci=90,
            scatter_kws = {'s':10, 'alpha':0.5},
            line_kws = {'color':'#ff7f00', 'alpha':0.6, 'lw':3})


# Plotting method for visualizing residuals using percentiles of residual data and bin averages
# Useful way to look at whether relationship between two variables is linear or not
# Plot values can be generated by ResidualPercentilePlotData function in dataStats module
percentiles = [.25,.50,.75]

for p in percentiles:
    cdfs_at_p = [rv.ppf(p) for rv in res_rvs]
    ax.plot(x_means, cdfs_at_p, label= p)
    

# Good settings for scatter plot with many overlapping points
ax.scatter(x, y, s=10, alpha=0.5)


# Good setting for semi-transparent line on top of scatter plot
ax.plot(x, y, c='#ff7f00', alpha=0.6, lw=3)


# Set matplotlib object properties
plt.setp(obj, prop=val)


# View all properties and available arguments for an object
plt.setp(obj)


# View current property and value settings for an object
plt.getp(obj)


#Get current figure to work with its properties
fig = plt.gcf()


# Get current axis to work with its properties
ax = plt.gca()


# Plot survival function for a KaplanMeierFitter object (kmf)
# See the analysis snippets for how to create this object
kmf.survival_function_.plot()


# Include a table at the bottom of survival funtion plot
kmf.plot(at_risk_counts=True)
plt.tight_layout()


# Grouped bar chart
labels = ['G1', 'G2', 'G3', 'G4', 'G5']
values1 = [20, 34, 30, 35, 27]
values2 = [25, 32, 34, 20, 25]

x = np.arange(len(labels))  # the label locations
width = 0.35  # the width of the bars

fig, ax = plt.subplots()
rects1 = ax.bar(x - width/2, values1, width, label='values1')
rects2 = ax.bar(x + width/2, values2, width, label='values2')

# Add some text for labels, title and custom x-axis tick labels, etc.
ax.set_ylabel('')
ax.set_title('')
ax.set_xticks(x)
ax.set_xticklabels(labels)
ax.legend()

# Add value labels to tops of the bars
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom')

autolabel(rects1)
autolabel(rects2)


# Stacked bar chart
n = 5
values1 = (20, 35, 30, 35, 27)
values2 = (25, 32, 34, 20, 25)
values1_std = (2, 3, 4, 1, 2)
values2_std = (3, 5, 2, 3, 3)
ind = np.arange(n)    # the x locations for the groups
width = 0.35       # the width of the bars: can also be len(x) sequence

p1 = plt.bar(ind, menMeans, width, yerr=menStd)
p2 = plt.bar(ind, womenMeans, width,
             bottom=menMeans, yerr=womenStd)

plt.ylabel('')
plt.title('')
plt.xticks(ind, ('G1', 'G2', 'G3', 'G4', 'G5'))
plt.yticks(np.arange(0, 81, 10))
plt.legend((p1[0], p2[0]), ('values1', 'values2'))


# Plot cdf of a discrete rv
# Includes orange line for the mean, grey lines for the CI, and a green line at zero
# The zero line is only used to show the pvalue in the case that the null hypothesis is zero
ax.plot(rv.xk, rv.cdf(rv.xk))
ax.axvline(rv.mean(), color='C1', lw=1.3) # mean, orange line
ax.axvline(rv.interval(0.95)[0], color='C4', lw=1.3, label='CI') # CI lower, green line
ax.axvline(rv.interval(0.95)[1], color='C4', lw=1.3) # CI upper, green line
ax.axvline(0, color='C3', lw=1.3) # p-value (if comparing with zero), red line


# Plot pmf of a discrete rv
ax.plot(rv.xk, rv.pmf(rv.xk), 'ro', ms=12, mec='r')
ax.vlines(rv.xk, 0, rv.pmf(rv.xk), colors='r', lw=4)


# Plots to generate a scatter plot with regression and CI
# fit_xs/ys come from the FitLine function
# low/high come from dsa.PercentileRows used after producing a sequence of ys with dsa.ResampleInterSlope
ax.scatter(xs, ys, color='C0', s=16, alpha=0.8)
ax.plot(fit_xs_a, fit_ys_a, color='C1')
ax.fill_between(fit_xs_a, low, high, color='C1', alpha=0.2)


# Waterfall chart
# First put data to plot into a Series
# This data should be in the form of the initial value, followed by the changes that happen
# The final net value is added later in the code
# The index will be the x-tick labels at the bottom of the chart
index = ['intial','A','B','C','D','E']
values = [350000,-30000,-7500,-25000,95000,-7000]
data = pd.Series(data=values,index=index)

blank=data.cumsum().shift(1).fillna(0)

total = data.sum()
data.loc["net"] = total
blank.loc["net"] = total

step = blank.reset_index(drop=True).repeat(3).shift(-1)
step[1::3] = np.nan

# Stops double stacking at the end
blank.loc["net"] = 0

# Plot the data
fig,ax = plt.subplots()
fig.set_size_inches(8,6)

width=0.7
rect = ax.bar(x=data.index, height=data.values, width=width, bottom=blank, edgecolor='C0')
ax.plot(step.index, step.values, color='C0', linestyle='dashed', lw=1)

# Make sure to set the ylim for the particular chart
ax.set_ylim(top=220)
ax.set_xlim(left=-width/2, right=(len(data)-1)+width/2) # Removes extra space on left and right of chart
ax.get_yaxis().set_visible(False)
ax.set_title('Waterfall Chart')

blank_bar_enum = list(enumerate(blank.values))
for x,y in enumerate(data.values):
    if (x == len(data)-2) | (x == len(data)-1):
        y_coord = data[len(data)-1]
    else:
        y_coord = blank_bar_enum[x+1][1]
    
    if (x == 0) | (x == len(data)-1): # First and last bar annotations
        offset = 6
        va ='bottom'
        sign = ''
    else: # All other bars
        if y < 0:
            offset = -6
            va ='top'
            sign = '-'
        elif y == 0:
            offset = 6
            va ='bottom'
            sign = ''
        else:
            offset = 6
            va ='bottom'
            sign = '+'
    
    # Can change str(abs(y)) below to dsa.DollarThousandsFormat(y) to annotate with dollar amounts
    plt.annotate(sign + str(abs(y)), xy=(blank_bar_enum[x][0], y_coord),
                 xytext=(0, offset),
                 textcoords="offset points",
                 ha='center', va=va,
                 fontsize=12,
                 weight='normal', color='0.4')
        
dsp.Despine(ax, spines='toprightleft')

plt.show()


# Plot multiple categorical variables from a dataframe
# Need to adjust number of rows to fit all variables in
# Do not adjust the number of columns
# Adjust the fig size to keep a good aspect ratio and be able to see all labels
# For 2x2 good fig sizes are 8,6 and 12,9
# For 3x2 good fig sizes are 8,9.5 and 12,13.5
# If only one row a good fig size is 13,3.5
# If one row also cannot use row and pos to index axes, just use i 
categorical_vars = ['var1', 'var2', 'var3', 'var4']
fig, axs = plt.subplots(nrows=2, ncols=2, sharex=False)
fig.set_size_inches(8,6)
for i, var in enumerate(categorical_vars):
    row = i//2
    pos = i % 2
    g = sns.countplot(x=var, data=df, ax=axs[row][pos])
    g.set_title(var)
    g.set_xlabel('')

plt.tight_layout()


# To visualize the relationship between two categorical variables use bar charts showing proportions/percentages
x,hue = 'var1','var2'
df1 = (df.groupby(x)[hue]
       .value_counts(normalize=True)
       .mul(100)
       .rename('percentage')
       .reset_index())
g = sns.catplot(x=x, y='percentage', hue=hue, kind='bar', data=df1)
g.ax.set_ylim(0,100)


# Can use a heatmap to visualize correlations between numerical variables
# Can use a mask as below to remove redundancies
mask = np.tril(df.corr())
sns.heatmap(df.corr(), cmap='coolwarm, center=0.0, annot=True, mask=mask)


# Plot multiple heatmaps for a categorical variable using groupby
# This only creates plots in one vertical row or one vertical column
# Need to adjust nrows/ncols, sharex/sharey, and fig size as needed
fig, axs = plt.subplots(nrows=1, ncols=3, sharex=False, sharey=True)
fig.set_size_inches(16,4)
for i, data in enumerate(df.groupby('cat_variable')):
    plot_num = i
    g = sns.heatmap(data[1].corr(), ax=axs[plot_num], cmap='coolwarm', center=0.0, annot=True)
    g.set_title(data[0])


# A normal probability plot and a fit line, data needs to be in array format
fit_xs, fit_ys = dsa.FitLine([-5,5], data.mean(), data.std())
xs, ys = dsa.NormalProbabilityValues(data)
ax.plot(fit_xs, fit_ys, color='0.8')
ax.plot(xs, ys)


# Plot cdfs of all numerical variables along with their means
# Need to adjust number of rows to fit all variables in
# Do not adjust the number of columns
# Adjust the fig size to keep a good aspect ratio and be able to see all labels
# For 2x2 good fig sizes are 8,6 and 12,9
# For 3x2 good fig sizes are 8,9.5 and 12,13.5
# If only one row a good fig size is 13,3.5
# If one row also cannot use row and pos to index axes, just use i 
numerical_vars = ['var1', 'var2', 'var3', 'var4']

fig, axs = plt.subplots(nrows=2, ncols=2, sharex=False)
fig.set_size_inches(8,6)

for i, var in enumerate(numerical_vars):
    # Creating a discrete_rv
    val,cnt = np.unique(df[var].dropna(), return_counts=True)
    var_rv = stats.rv_discrete(values=(val,cnt/sum(cnt)))
    
    row = i//2
    pos = i % 2
    ax=axs[row][pos]
    ax.plot(var_rv.xk, var_rv.cdf(var_rv.xk))
    ax.axvline(x=var_rv.mean(), color='C1')
    ax.set_title(var)

plt.tight_layout()


# Make all xticklabels and xlabels appear in a seaborn plot that uses col_wrap
# Check to be sure that the order of x ticks is preserved when doing this
for ax in g.axes:
    ax.set_xticklabels(list(df.variable_name.unique()), visible=True)
    ax.set_xlabel(variable_name)

plt.subplots_adjust(hspace=0.3)
